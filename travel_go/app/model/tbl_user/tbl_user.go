// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package tbl_user

import (
	"database/sql"
	"github.com/gogf/gf/crypto/gsha1"
	"github.com/gogf/gf/frame/g"
	"github.com/gogf/gf/util/grand"
	"time"
)

// Fill with you ideas below.
const salt = "u!a@)9gws@$8xkw4^2z^)31(&=&o2l9k&gwgpmdvpnaw9bvy9f"

// 保证相同的密码加密成不同的密文
func createPassword(s string) string {
	randString := grand.Str(salt, 6)
	encryptStr := randString + salt + s
	return randString + gsha1.Encrypt(encryptStr)
}

// 判断两个密码是否一致
func checkPassword(password, realPassword string) bool {
	randString := realPassword[0:6]
	encryptStr := randString + salt + password
	encryptPassword := randString + gsha1.Encrypt(encryptStr)
	return encryptPassword == realPassword
}

// 判断邮箱是否存在
func ExistEmail(email string) (bool, error) {
	record, err := g.DB().Table(Table).FindOne("email=?", email)
	if err != nil || record != nil {
		return true, err
	}
	return false, err
}

// 创建用户
func CreateUser(email, password string) (sql.Result, error) {
	password = createPassword(password)
	data := g.Map{
		Columns.Email:      email,
		Columns.Password:   password,
		Columns.CreateTime: time.Now().Format("2006-01-02 15:04:05"),
		Columns.IsDelete:   false,
		Columns.Active:     false,
	}
	return g.DB().Table(Table).Insert(data)
}

// 登录认证
func Authenticate(email, password string) (*Entity, bool) {
	user, err := Model.FindOne("email=?", email)
	if err != nil || user == nil {
		return user, false
	}
	if !checkPassword(password, user.Password) {
		return nil, false
	}
	return user, true
}
